<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProbeSimulator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GROUP09_2021</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">ProbeSimulator.java</span></div><h1>ProbeSimulator.java</h1><pre class="source lang-java linenums">

import src.main.java.titan.Vector3dInterface;
import src.main.java.Vector3d;
import titan.ProbeSimulatorInterface;
import titan.StateInterface;
import titan.ODEFunctionInterface;


import src.main.java.titan.RateInterface;

public class ProbeSimulator implements ProbeSimulatorInterface {

    private Vector3dInterface[] coordinatesProbe;

    private final StateInterface[] states;
    private static final double mass = 15e3;
<span class="fc" id="L18">    private static final double G = 6.674 * Math.pow(10, -11);</span>

<span class="pc" id="L20">    private double[] masses = new double[11];</span>

<span class="nc" id="L22">    public ProbeSimulator(StateInterface[] states, double h) {</span>
<span class="nc" id="L23">        this.states = states;</span>
<span class="nc" id="L24">        State state = (State) states[0];</span>
<span class="nc" id="L25">        this.masses = state.masses;</span>

<span class="nc" id="L27">        this.coordinatesProbe = trajectory(new Vector3d(-1.471922101663588e+11, -2.860995816266412e+10+6371e3, 8.278183193596080e+06), new Vector3d(5.427193405797901e+03, -2.931056622265021e+04, 6.575428158157592e-01), 31536000, h);</span>
<span class="nc" id="L28">    }</span>
<span class="fc" id="L29">    public ProbeSimulator() {</span>
<span class="fc" id="L30">        states = new StateInterface[2];</span>
<span class="fc" id="L31">    }</span>

    public Vector3dInterface[] getCoordinatesProbe() {
<span class="nc" id="L34">        return coordinatesProbe;</span>
    }

    private Vector3dInterface calculateF(Vector3dInterface coordinatesProbe, Vector3dInterface[] coordinates) {
<span class="nc" id="L38">        Vector3dInterface force = new Vector3d(0,0,0);</span>
        // Loops through all the bodies and adds the force of each body on the probe to the total force
<span class="nc bnc" id="L40" title="All 2 branches missed.">        for(int i = 0; i &lt; coordinates.length; i++) {</span>
<span class="nc" id="L41">            double mm = (masses[i] * mass);</span>
<span class="nc" id="L42">            double distance = coordinatesProbe.dist(coordinates[i]);</span>
<span class="nc" id="L43">            Vector3dInterface unitVector = (coordinatesProbe.sub(coordinates[i])).mul(1/distance);</span>
<span class="nc" id="L44">            force = force.add(unitVector.mul(-G * mm/Math.pow(distance, 2)));</span>
        }
<span class="nc" id="L46">        return force;</span>
    }

    private Vector3dInterface calculateRate(Vector3dInterface force, double h) {
<span class="nc" id="L50">        Vector3dInterface rate = new Vector3d(force.getX()/mass, force.getY()/mass, force.getZ()/mass);</span>
<span class="nc" id="L51">        rate = rate.mul(h);</span>
<span class="nc" id="L52">        return rate;</span>
    }

    @Override
    public Vector3dInterface[] trajectory(Vector3dInterface p0, Vector3dInterface v0, double[] ts) {
<span class="nc" id="L57">        return new Vector3dInterface[0];</span>
    }

    /**
     * Method which recalculates the trajectory of the probe and updates the states with the recalculated trajectory.
     * @param p0 starting coordinates !RELATIVE TO EARTH!
     * @param v0 starting velocity !RELATIVE TO EARTH!
     * @param tf the final time
     * @param h the sizeof step to be taken
     * @return an array of the coordinates of the probe !RELATIVE TO THE SOLAR SYSTEM BARYCENTRE!
     */
    @Override
    public Vector3dInterface[] trajectory(Vector3dInterface p0, Vector3dInterface v0, double tf, double h) {
        //create reference Objects
<span class="fc" id="L71">        ODEFunctionInterface f = new ODEFunction();</span>
<span class="fc" id="L72">        ODESolver ode = new ODESolver();</span>
        //set up the data
<span class="fc" id="L74">        Vector3dInterface[] probeCoordinates = new Vector3dInterface[(int) ((tf/h)+2)];</span>
<span class="fc" id="L75">        probeCoordinates[0] = p0;</span>
<span class="fc" id="L76">        Vector3dInterface[] coordinates = ode.getCoordinates();</span>
<span class="fc" id="L77">        Vector3dInterface[] velocities = ode.getVelocities();</span>
<span class="fc" id="L78">        coordinates[11] = coordinates[3].add(p0);</span>
<span class="fc" id="L79">        velocities[11] = velocities[3].add(v0);</span>
        //set up the storing values for the calculation
<span class="fc" id="L81">        StateInterface[] states = new StateInterface[(int) ((tf/h)+2)];</span>
<span class="fc" id="L82">        states = new StateInterface[(int) ((tf/h)+2)];</span>
<span class="fc" id="L83">        states[0] = new State(coordinates, velocities, 0);</span>

<span class="fc" id="L85">        int t = 0;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        for(int i = 1; i &lt; states.length; i++) {</span>
            //for each step perform the chossen step and set the value
<span class="fc" id="L88">            t += h;</span>
            //step = Eulers; RKstep = Runge-Kutte; verletStep = Verlet solver
<span class="fc" id="L90">            states[i] = ode.verletStep(f, t, states[i-1], h);</span>
<span class="fc" id="L91">            State state = (State) states[i];</span>
<span class="fc" id="L92">            probeCoordinates[i] = state.getCoordinates()[11];</span>
        }
<span class="fc" id="L94">        return probeCoordinates;</span>
    }

    /* EULER'S METHOD
        int t = 0;

        Vector3dInterface[] coordinates = new Vector3dInterface[(int) ((tf/h)+1)];
        Vector3dInterface v = v0;
        coordinates[0] = p0;

        for(int i = 1; i &lt; coordinates.length; i++) {
            t += h;
            State state = (State) states[i-1];
            Vector3dInterface force = calculateF(coordinates[i-1], state.getCoordinates());
            Vector3dInterface rate = calculateRate(force, h);
            v = v.add(rate);
            coordinates[i] = coordinates[i-1].addMul(h, v);
        }

        return coordinates;
     */

    /* BAD RK
        int t = 0;

        Vector3dInterface[] coordinates = new Vector3dInterface[(int) ((tf/h)+1)];
        Vector3dInterface v = v0;
        coordinates[0] = p0;

        for(int i = 1; i &lt; coordinates.length; i++) {
            t += h;
            State state = (State) states[i-1];
            Vector3dInterface force = calculateF(coordinates[i-1], state.getCoordinates());
            Vector3dInterface rate1 = calculateRate(force, h);
            Vector3dInterface cTemp = coordinates[i-1].addMul(h*0.5, rate1);
            force = calculateF(cTemp, state.getCoordinates());
            Vector3dInterface rate2 = calculateRate(force, h*1.5);
            cTemp = coordinates[i-1].addMul(h*0.5, rate2);
            force = calculateF(cTemp, state.getCoordinates());
            Vector3dInterface rate3 = calculateRate(force, h*1.5);
            cTemp = coordinates[i-1].addMul(h, rate3);
            force = calculateF(cTemp, state.getCoordinates());
            Vector3dInterface rate4 = calculateRate(force, h*2);

            Vector3dInterface rateTot = rate1.addMul(2, rate2).addMul(2, rate3).addMul(1, rate4).mul(1.0/6.0);

            v = v.add(rateTot);
            coordinates[i] = coordinates[i-1].addMul(h, v);
        }

        return coordinates;
     */

    /* ATTEMPT AT GOOD RK
        int t = 0;

        StateInterface[] statesWithProbe = new StateInterface[(int) ((tf/h)+1)];

        Vector3dInterface[] probeCoordinates = new Vector3dInterface[(int) ((tf/h)+1)];

        State s0 = (State) states[0];
        Vector3dInterface[] coordinates = s0.getCoordinates();
        Vector3dInterface[] velocities = s0.getVelocities();

        Vector3dInterface[] coordinatesWithProbe = new Vector3dInterface[coordinates.length+1];
        Vector3dInterface[] velocitiesWithProbe = new Vector3dInterface[velocities.length+1];

        System.arraycopy(coordinates, 0, coordinatesWithProbe, 0, coordinates.length);
        System.arraycopy(velocities, 0, velocitiesWithProbe, 0, velocities.length);

        coordinatesWithProbe[coordinatesWithProbe.length-1] = p0;
        velocitiesWithProbe[velocitiesWithProbe.length-1] = v0;

        probeCoordinates[0] = coordinatesWithProbe[coordinatesWithProbe.length-1];
        s0 = new State(coordinatesWithProbe, velocitiesWithProbe, 0);
        statesWithProbe[0] = s0;
        ODEFunctionInterface f = new ODEFunction();

        for(int i = 1; i &lt; states.length; i++) {
            t += h;
            statesWithProbe[i] = RKstep(f, t, statesWithProbe[i-1], h);
            State curState = (State) statesWithProbe[i];
            Vector3dInterface[] curCoordinates = curState.getCoordinates();
            probeCoordinates[i] = curCoordinates[curCoordinates.length-1];
        }

        return probeCoordinates;
     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>